#lang racket
(require racket)

#|

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

    Starting with any positive integer, replace the number by the sum
of the squares of its digits.  Repeat the process until the number
equals 1 (where it will stay), or it loops endlessly in a cycle which
does not include 1.  Those numbers for which this process ends in 1
are happy.

Return true if n is a happy number, and false if not.

Example 1:

Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

Example 2:

Input: n = 2
Output: false

|#

#|

idea
do it by the books, with recursion of course

first we need functionality number->digit-list

we can get the happy path easily enough

we also need a cycle detecting algorithm

|#

(require (only-in srfi/1 unfold-right))
         (only-in srfi/26 cut))

(define (int->digit-list int)
  (unfold-right zero? (cut remainder <> 10) (cut quotient <> 10) int))

(define (square x) (* x x))

(foldl + 0 (map square (int->digit-list 19)))

(let loop ([res 2]
           [counter 20])
  (displayln (format "res: ~a" res))
  (cond [(zero? counter) 'nope]
        [(= 1 res) #t]
        [else
         (loop (foldl + 0 (map square (int->digit-list res))) (sub1 counter))]))

(define (check-happy res)
  (displayln (format "res: ~a" res))
  (if (= 1 res)
      #t
      (check-happy (foldl + 0 (map square (int->digit-list res))))))

(check-happy 2)

;; cycle detection
;; example: 2


(define (floyd f x0)
  ;; the tortoise starts from the first element
  (define tortoise (f x0))

  ;; the hare starts from the second element
  (define hare (f (f x0)))

  ;; loop until the tortoise and hare pointers meet
  (let loop ((tortoise tortoise) (hare hare))
    (if (eq? tortoise hare)
        ;; a cycle detected, find the length
        (let loop2 ((hare (f hare)) (lam 1))
          (if (eq? tortoise hare)
              ;; once we are back at start of cycle, we know its length
              lam
              (loop2 (f hare) (+ lam 1))))
        (loop (f tortoise) (f (f hare))))))

;; define the transformation function
(define (f x) (modulo (* 57 x) 97))

;; find cycle in sequence generated by f from 10
(define cycle (floyd f 10))

(floyd check-happy 2)


;; given a sequence of numbers, determine if there is a cycle
(define excycle '(2 4 16 37 58 89 145 42 20 4 16 37 58 89 145 42 20 4 16 37 58))

(let ([nums (list->vector excycle)])
  (let loop ([tort-pos 0]
             [hare-pos 1])
    (let ([tort (vector-ref nums tort-pos)]
          [hare (vector-ref nums hare-pos)])
      (displayln (format "~a: ~a ~a: ~a" tort-pos tort hare-pos hare))
      (if (equal? tort hare)
        #t
        (loop (add1 tort-pos)
              ((compose add1 add1) hare-pos))))))


(define (floyds vec)
  (let loop ([tort-pos 0]
             [hare-pos 1])
    (if (or (> hare-pos (sub1 (vector-length vec)))
            (> tort-pos (sub1 (vector-length vec))))
        #f
        (let ([tort (vector-ref vec tort-pos)]
              [hare (vector-ref vec hare-pos)])
          ;; (displayln (format "~a: ~a ~a: ~a" tort-pos tort hare-pos hare))
          (if (equal? tort hare)
              #t
              (loop (add1 tort-pos)
                    ((compose add1 add1) hare-pos)))))))


(floyds (list->vector excycle))
(floyds (list->vector '(19 82 68 100 19 82 68 100 19)))

#|

idea:

try the number
as it's going, keep a running list of the items and check for cycles
maybe every 20 numbers to save on compute?

|#

(require (only-in srfi/1 unfold-right)
         (only-in srfi/26 cut))

(define (int->digit-list int)
  (unfold-right zero? (cut remainder <> 10) (cut quotient <> 10) int))

(define (square x) (* x x))

(define (floyds vec)
  (let loop ([tort-pos 0]
             [hare-pos 1])
    (if (> hare-pos (sub1 (vector-length vec)))
        #f
        (let ([tort (vector-ref vec tort-pos)]
              [hare (vector-ref vec hare-pos)])
          (if (equal? tort hare)
              #t
              (loop (add1 tort-pos)
                    ((compose add1 add1) hare-pos)))))))


(define (is-happy res [acc '()])
  (cond [(= 1 res) #t]
        [(and (> (length acc) 20) (floyds (list->vector acc))) #f]
        [else (is-happy (foldl + 0 (map square (int->digit-list res))) (cons res acc))]))

(check-happy 19)
(check-happy 2)
